# -*- coding: utf-8 -*-
"""Sazid_Fatima_Lab4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1w-QnOB4pwNyDkrFBSHxwiqSiT13IP4wO
"""

import numpy as np
from matplotlib import pyplot as plt
from PIL import Image
import math
from skimage.draw import line

# Load grid map
image = Image.open('map1.png').convert('L')
grid_map = np.array(image.getdata()).reshape(image.size[0],image.size[1])/255
# binarize the image
grid_map[grid_map > 0.5] = 1
grid_map[grid_map <= 0.5] = 0
# Invert colors to make 0 -> free and 1 -> occupied
grid_map = (grid_map * -1) + 1
# Show grid map
plt.matshow(grid_map)
plt.colorbar()
plt.show()

def PixelCoordinatesOfLine(p1, p2, vertices):
    # This function calculates the pixels in an image between two points (p1 and p2) using the 'line' function.

    # If p2 is an integer or a NumPy int64, set a to p2, otherwise, use the first element of p2.
    a = p2 if isinstance(p2, (int, np.int64)) else p2[0]

    # Get the ROWS and COLUMNS using the 'line' function with the coordinates of points p1 and a.
    ROWS, COLUMNS = line(vertices[p1][0], vertices[p1][1], vertices[a][0], vertices[a][1])

    # Return the calculated ROWS and COLUMNS.
    return ROWS, COLUMNS

def RAND_CONF(p, vertices):
    # Choose a random vertex with predefined probabilities.

    # Calculate the probability for each vertex, setting a higher probability for the last vertex.
    prob = [(1 - p) / (len(vertices) - 1)] * len(vertices)
    prob[-1] = p

    # Use NumPy's random.choice to select a vertex based on the calculated probabilities.
    selected_vertex = np.random.choice(list(range(len(vertices))), 1, p=prob)

    # Return the randomly chosen vertex.
    return selected_vertex

def NEAREST_VERTEX(qrand, G_Vertices, vertices):
    # Compute the nearest vertex to the randomly selected pixel (vertex) obtained from the RAND_CONF function.

    # If qrand is an integer or a NumPy int64, set it to qrand; otherwise, use the first element of qrand.
    qrand = qrand if isinstance(qrand, (int, np.int64)) else qrand[0]

    # Initialize distance to a large value.
    distance = 10000000

    # Iterate through vertices in G_Vertices to find the nearest one to the qrand vertex.
    for i in range(len(G_Vertices)):
        # Calculate the Euclidean distance between qrand vertex and the current vertex in G_Vertices.
        current_distance = math.dist(vertices[qrand], vertices[G_Vertices[i]])

        # Update the nearest vertex and its distance if the current vertex is closer.
        if current_distance < distance:
            distance = current_distance
            index = i

    # Return the index of the nearest vertex in G_Vertices.
    return G_Vertices[index]

def IS_SEGMENT_FREE(qnear, qnew, vertices):
  # a funciton that checks if the straight line that connects (qnear and qnew) doesn't interest an obstacle
  if isinstance(qnew, list): # If qnew is given as a list, convert it to its corresponding index in vertices.
    a=[qnew[0],qnew[1]] # Convert the list qnew to a point [qnew[0], qnew[1]]
    for j in range (len(vertices)):  # Find the index of the point in vertices
      if a==vertices[j]:
        new=j
        break
    qnew = new
  rows, columns = PixelCoordinatesOfLine(qnear, qnew, vertices) # Get the pixel coordinates of the line between qnear and qnew.
  for i in range(len(rows)):
    a=[rows[i],columns[i]]  # Get the pixel coordinates [rows[i], columns[i]]
    if a in vertices: # Check if the pixel is in the list of vertices
      flag=True
    else:
      flag=False
      return flag
  return flag

def NEW_CONF(qnear, qrand, delta_q, vertices):
    # Ensure that the randomly selected pixel (qrand) is within the allowable distance (delta_q) from the nearest pixel (qnear).
    # If not, select a new pixel within the allowable distance (delta_q) along the straight line connecting qnear and qrand.

    # If qrand is an integer or a NumPy int64, set it to qrand; otherwise, use the first element of qrand.
    if isinstance(qrand, int) or isinstance(qrand, np.int64):
        qrand = qrand
    else:
        qrand = qrand[0]

    # If qnear is an integer or a NumPy int64, set it to qnear; otherwise, use the first element of qnear.
    if isinstance(qnear, int) or isinstance(qnear, np.int64):
        qnear = qnear
    else:
        qnear = qnear[0]

    # Check if the distance between qrand and qnear is within the allowable range (delta_q).
    if math.dist(vertices[qrand], vertices[qnear]) <= delta_q:
        # If yes, return qrand as it is an acceptable configuration.
        return qrand
    else:
        # If not, find a new configuration within the allowable distance along the line connecting qnear and qrand.

        # Get the pixel coordinates of the line between qrand and qnear.
        rows, columns = PixelCoordinatesOfLine(qrand, qnear, vertices)

        for i in range(len(rows)):
            # Check if the distance between the current pixel and qnear is within the allowable range (delta_q)
            # and if the segment between qnear and the current pixel is obstacle-free.
            if math.dist([rows[i], columns[i]], vertices[qnear]) < delta_q and IS_SEGMENT_FREE(qnear, [rows[i], columns[i]], vertices):
                continue
            else:
                # If not, find the index of the previous pixel in vertices and return it as the new configuration.
                a = [rows[i - 1], columns[i - 1]]
                for j in range(len(vertices)):
                    if a == vertices[j]:
                        return j

def FILL_PATH(G_Vertices, G_Edges, vertices):
    # Extract the path from the graph of vertices computed by the RRT algorithm.

    # Initialize the path with the goal vertex (last vertex in the list of vertices).
    path = [len(vertices) - 1]

    # Iterate through the edges in reverse order to reconstruct the path.
    for i in range(len(G_Edges)):
        j = i + 1

        # Check if the starting vertex of the current edge matches the first vertex in the path.
        if path[0] == G_Edges[-1 * j][1]:
            # Update the pointer to the other end of the edge.
            pointer = G_Edges[-1 * j][0]

            # Insert the pointer at the beginning of the path if it's not already in the path.
            if pointer not in path:
                path.insert(0, pointer)

                # If the pointer is the start vertex, return the path.
                if pointer == 0:
                    return path

def total_path_dist(nodes, vertices):
    # Calculate the distance of the path from qstart to qgoal.

    # Using a list comprehension to calculate distances between consecutive vertices and sum them up.
    distance = sum(math.dist(vertices[nodes[i]], vertices[nodes[i + 1]]) for i in range(len(nodes) - 1))

    # Return the total distance of the path.
    return distance



def RRT(C, K, delta_q, p, qstart, qgoal):
    G_Verteices = [0]  # stores all the vertices in the graph formed by the RRT algorithm
    G_Edges = []  # stores all the edges that connect the vertices in the graph formed by the RRT algorithm
    c = np.shape(C)  # This is the map or environment upon which the RRT algorithm is applied
    vertices = []  # all the pixels of the image that are on the free spaces

    indicator_start = 0  # indicator used to check if the given starting point is in free space
    indicator_goal = 0  # indicator used to check if the given goal point is in free space

    # storing all the free space of the map in the variable called vertices
    for i in range(c[0]):
        for j in range(c[1]):
            if C[i][j] == 0:
                vertices.append([i, j])

    # sorting the vertices i.e making the starting vertex in the first position of the vertices variable
    indicator_start, vertices = sort_vertex(qstart, vertices, 0)

    # sorting the vertices i.e making the goal vertex at the last position of the vertices variable
    indicator_goal, vertices = sort_vertex(qgoal, vertices, -1)

    if not indicator_goal and indicator_start:
        print("Either the given starting point or the goal point or both is/are inside an obstacle! ")
        return None

    for i in range(K):
        qrand = RAND_CONF(p, vertices)
        qnear = NEAREST_VERTEX(qrand, G_Verteices, vertices)
        qnew = NEW_CONF(qnear, qrand, delta_q, vertices)

        if IS_SEGMENT_FREE(qnear, qnew, vertices):
            if qnew not in G_Verteices:
                G_Verteices.append(qnew)
            if [qnear, qnew] not in G_Edges:
                G_Edges.append([qnear, qnew])

            if vertices[qnew] == vertices[-1]:
                return print_path_info(G_Verteices, G_Edges, vertices)

            goal_distance = math.dist(vertices[qnew], vertices[-1])
            if goal_distance <= delta_q and IS_SEGMENT_FREE((len(vertices) - 1), qnew, vertices):
                if (len(vertices) - 1) not in G_Verteices:
                    G_Verteices.append(len(vertices) - 1)
                if [qnew, (len(vertices) - 1)] not in G_Edges:
                    G_Edges.append([qnew, (len(vertices) - 1)])
                return print_path_info(G_Verteices, G_Edges, vertices)

    return print("No solution found")


def sort_vertex(q, vertices, position):
    # Sort the vertices list by swapping the element at the specified position with the element equal to q.

    indicator = 0  # Initialize the indicator variable

    # Iterate through vertices to find the index of q
    for i in range(len(vertices)):
        if q == vertices[i]:
            # Swap the elements at the specified position and the index of q
            vertices[position], vertices[i] = vertices[i], vertices[position]
            indicator = 1  # Set the indicator to 1 to indicate a successful swap
            break

    return indicator, vertices



def print_path_info(verteices, edges, vertices):
    PATH = FILL_PATH(verteices, edges, vertices)
    print("Path Found after ", len(PATH) - 1, "Iterations")
    print("The total distance is: ", total_path_dist(PATH, vertices))
    print("The Path to Follow is: ")
    for j in range(len(PATH)):
        print(vertices[PATH[j]])
    print("The chosen vertices to form the path are:")
    print(PATH)
    return PATH, vertices, edges

[path,vertices_list, edge] = RRT(grid_map, 10000, 10, 0.2, qstart=[10, 10], qgoal=[90, 70])

# Plotting the optimal path computed
x=[]
y=[]
optimal_path=[]
for i in range(len(path)):
  optimal_path.append(vertices_list[path[i]])
for j in range(len(optimal_path)):
  v=optimal_path[j]
  x.append(v[0])
  y.append(v[1])

x=np.array(x)
y=np.array(y)


w=[]
z=[]
branches=[]
for i in range(len(edge)):
  coord1=vertices_list[edge[i][0]]
  coord2=vertices_list[edge[i][1]]
  w=[coord1[0],coord2[0]]
  z=[coord1[1],coord2[1]]
  plt.plot(z, w, marker='', color="green")

plt.plot(y, x, marker='', color="red")
plt.imshow(grid_map)
plt.show()

# Smoothing the computed path
optimal_path_new=[vertices_list[path[len(path) - 1]]]
s= len(path) - 1
st=[]
a=[]
while vertices_list[0] not in optimal_path_new:
  for j in range(len(path)):
    if IS_SEGMENT_FREE(path[s], path[j], vertices_list):
      optimal_path_new.append(vertices_list[path[j]])
      s=j
      st.append(s)
      break

print("The smoothed distance is: ")
print(total_path_dist(st , vertices_list))
print("The Path to Follow is: ")
for i in range(len(optimal_path_new)):
  #a.append([optimal_path_new[len(optimal_path_new)-1-i]])
  print(optimal_path_new[len(optimal_path_new)-1-i])
  print(a)

# Plotting the computed optimized path
x=[]
y=[]

for j in range(len(optimal_path_new)):
  v=optimal_path_new[j]
  x.append(v[0])
  y.append(v[1])

x=np.array(x)
y=np.array(y)


w=[]
z=[]
branches=[]
for i in range(len(edge)):
  coord1=vertices_list[edge[i][0]]
  coord2=vertices_list[edge[i][1]]
  w=[coord1[0],coord2[0]]
  z=[coord1[1],coord2[1]]
  plt.plot(z, w, marker='', color="green")

plt.plot(y, x, marker='', color="red")
plt.imshow(grid_map)
plt.show()